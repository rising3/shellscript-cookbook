---
title: レシピ1-9 関数
---

import { Code } from '@astrojs/starlight/components';
import importedCode from '/samples/01/01_hello_world.sh?raw';

他のプログラミング言語と同様に、bashでも関数を定義し、使用できる。

bashでは、次のように関数を定義する。

```bash
function 関数名() {
  処理
}
```

`function` か、関数名の後ろのカッコ `()` を省略することができる。

:::note[関数名の命名規約]
紹介した Google Shell Style Guide には、関数名の命名規約について書かれている。
- 小文字を使用し、単語の区切りにはアンダースコア( `_` )を使用する
- ライブラリは `::` で区切る
- 関数名の後のカッコ`()`は必須である。
`function`は任意であるが、その使用の有無はプロジェクト全体で一貫させること
:::

## 引数

bashの関数は、他のプログラミング言語と同様に引数を指定することができる。
関数の引数は、コマンドライン引数と同様に位置パラメータを使用する。
関数内で位置パラメータを参照する場合は、
関数の呼び出し元で設定した引数が、関数内で位置パラメータとして取得できるようになる。

```bash
echo_args() {
  echo "${0}"
  echo "${1} ${3}"
  echo "${@}"
  echo "${*}"
  echo "${#}"
  echo "${FUNCNAME[0]}"
}

# 引数を指定して関数を呼び出す
echo_args arg1 arg2 arg3
```

`$0`は、コマンドラインの位置パラメータと同様にスクリプト名が格納される。
関数名は、`FUNCNAME`というbash変数をから取得できる。

- **`{FUNCNAME[0]}`:** 自身の関数名
- **`{FUNCNAME[1]}`:** 呼び出し元の関数名

:::note[位置パラメータの有効範囲について]
関数の位置パラメータは、その関数内でのみ有効である。
また関数内ではコマンドライン引数の位置パラメータの参照はできない。
:::

## 戻り値

bashの関数は、他のプログラミング言語と違い、関数の処理結果を戻り値として設定することができない。
代わりに、終了ステータスを返す。
関数の呼び出し側では、`$?` で関数の終了ステータスを確認する。
bashの関数は、関数内で最後に実行したコマンドの終了ステータスがその関数の終了ステータスとして返却される。
明示的に関数の終了ステータスを返却したい場合は、bashのビルドインコマンドの `return` を使用する。

```bash
return 終了ステータス
```

終了ステータスは数値で、一般的には0が正常で0以外が異常とする習慣がある。
`return` の位置で関数の処理は終了し、指定した数値が関数の終了ステータスとなる。

:::tip[実行順序]
シェルに対して入力されたコマンドは、次の優先順位が付けられている。

1. エイリアス
1. if や for などのキーワード
1. 関数
1. cd や type などのビルトインコマンド
1. スクリプトや実行可能ファイル

同じ名前の関数とシェルスクリプトがある場合は、関数の方が優先される。
:::

## ローカル変数

bashは、シェルスクリプト内のどこで変数を宣言してもグローバル変数として取り扱われる。
グローバル変数は、有効範囲が広く何処からでも参照や代入ができる。
関数内で使用する変数は、必要がない限りグローバル変数の使用は避けたい。
そのような場合、関数内ではローカル変数を使用する。

ローカル変数とは、宣言した関数内でのみ有効な変数のことで 変数の宣言時に`local`を追加する。

```bash
local 変数名
```

グローバル変数と同じ名前のローカル変数を関数内で宣言した場合、グローバル変数を書き換えることなく処理を書くことができる。
```bash
name=foo

func() {
  local name
  name='bar'
  echo "${name}"
}

echo "${name}" # fooが表示される
func           # ローカル変数のnameが使用され、bar
echo "${name}" # fooが表示される
```

:::danger[ローカル変数の宣言と代入の行は分離する]
紹介した Google Shell Style Guide には、ローカル変数の宣言と代入の行は分離することを求めている。

**良い例:**

```bash
func() {
  local my_var
  my_var="$(my_func)"
  (( $? == 0 )) || return
}
```

**悪い例:**

```bash
func() {
  # $? は常にゼロになる。
  # my_funcの終了ステータスではなく、localの終了ステータスを保持するため。
  local my_var="$(my_func)"
  (( $? == 0 )) || return
}
```

:::